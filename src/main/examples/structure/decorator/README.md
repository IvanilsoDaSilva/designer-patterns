<!-- Caracter Icon -->

──────▄▀▄─────▄▀▄  
─────▄█░░▀▀▀▀▀░░█▄  
─▄▄──█░░░░░░░░░░░█──▄▄  
█▄▄█─█░░▀░░┬░░▀░░█─█▄▄█

<!-- Animated img -->
<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=FF00FF&height=120&section=header"/>

<!-- Animated text -->
<div align="center">
  <img src="https://readme-typing-svg.herokuapp.com/?color=FF00FF&size=35&center=true&width=290&lines=DECORATOR"/>
</div>

<h2 align="right">PROBLEMA ❌</h2>

O problema que o padrão Decorator resolve é como estender a funcionalidade de objetos de forma flexível e modular, sem usar subclasses excessivas ou modificar a classe base. Em vez disso, você pode encapsular o objeto original em uma série de decoradores, cada um adicionando sua própria funcionalidade, formando uma cadeia de responsabilidade.

<h2 align="right">SOLUÇÃO 💡</h2>

Ele funciona encapsulando o objeto original em uma série de objetos decoradores, cada um adicionando seu próprio comportamento sem alterar a estrutura do objeto original. Os decoradores são empilhados uns sobre os outros, formando uma cadeia, e cada um delega chamadas de método para o próximo nível na cadeia, permitindo a composição flexível de funcionalidades adicionais. Isso permite que novas funcionalidades sejam adicionadas ou removidas facilmente, sem afetar outras partes do código.

<!-- Animated img -->
<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=FF00FF&height=120&section=footer"/>
